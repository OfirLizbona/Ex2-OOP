giladepsh,ofir.1
206972838,318722097

1. בחרנו בהעלמת לבנים בצורה הבאה:
כל אסטרטגיה מחזיקה כשדה רפרנס לbricksManger (מחלקה שאחראית על ניהול הלבנים במשחק)
על מנת להעלים לבנה מהמשחק אסטרטגיה קוראת לשיטה removeBrick של הBricksManager עם פרמטרים של שורה ועמודה
מנהל הלבנים מחזיק מצביע לכל לבנה במערך דו מימדי ובנוסף מצביע למנהל המשחק
האחריות הבלעדית להסרת אובייקטים מהמשחק היא באמצעות השיטה הציבורית removeObject של מנהל המשחק
יתרונות: הבחירה להשאיר את כל הלוגיקה להסרת אובייקטים תחת מנהל המשחק מאפשרת גמישות רבה -
במידה ונרצה לשנות את האופן שבו מנהלים את הסרת האובייקטים נדרש לשנות פונקציה בודדת בכל התוכנית
כל זאת בהתאמה לעקרון האנקפסולציה שנלמד.
חסרונות: כל מחלקה שמעוניינת להסיר אובייקטים נדרשת להחזיק מצביע לGameManager

2. בחרנו בהצגת החיים של השחקן באמצעות מחלקת LiveManager שתנהל את כל החיים של שחקן.
המחלקה מחזיקה רפרנס לGameManager ובאמצעותה מנהלת את הצגת האובייקטים.
בתוך המחלקה אנחנו מבצעים את פעולת ההצגה של מספר החיים, שינוי הצבע, תצוגת הלבבות ועדכון כל הנתונים הנדרשים.
המחלקות שהוספנו קוד לצרכי ניהול מספר החיים של שחקן:
LiveManager - מנהלת את החיים והצגתם על המסך
בתוך המחלקה Heart שמטרתה לייצר את הלב הנופל באסטרטגיית ExtraLives
מוחזק רפרנס למנהל החיים כיוון שרק דרכו ניתן לעדכן את כמות והצגת החיים בפועל של השחקן.
מימוש זה נעשה גם לאור עקרון האנקפסולציה

3. לצורך ניהול ההתנהגויות המיוחדות בחרנו בתבנית עיצוב של CollisionStrategyFactory
העיצוב מאפשר שליטה על ההסתברויות לקבלת כל אחת מההתנהוגויות הרצויות ויצירתן בהתאמה לדרישות.
BlowingBrickCollisionStrategy
במחלקת ניהול הלבנים הוספנו שיטה פומבית המאפשרת לקבל מצביע ללבנה בהינתן קורדינטות.
לכל לבנה שקיימת במקומות המוגדרים לפיצוץ בהתנהגות הזו נבצע את הonCollision שלה.
אם יש שתי לבנים מתפוצצות סמוכות זו לזו הלבנה הראשונה מסירה את עצמה מהמשחק לפני הקריאה לפיצוץ הלבנה השניה
ובכך נמנע פיצוץ רקורסיבי אינסופי.
ExtraLivesCollisionStrategy
ההתנהגות יוצרת אובייקט ייעודי מסוג Heart ומוסיפה אותו כgameObject באמצעות רפרנס לgameManager
הלב שנוצר מחזיק גם הוא רפרנס למנהל המשחק שבאמצעותו ישנה גישה למנהל החיים.
באופן זה הלב הוא ישות עצמאית שיכולה לגרום להוספת חיים או להעלים את עצמה מהמשחק (כשיוצאת מהמסך).
ExtraPaddleCollisionStrategy
בכדי לממש את ההתנהגות יצרנו מחלקה חדשה של ExtraPaddle שיורשת ממחלקת Paddle המקורית,
באמצעות המחלקה החדשה נוכל לנהל את כמות הפגיעות בה עד להעלמות ללא הוספת פונקציונליות מיותרת
למחלקה המקורית.
בנוסף, הוספנו למנהל המשחק שדה בוליאני שמציין האם כבר קיים אובייקט מסוג זה
כדי לשמור על מגבלה של מחבט נוסף יחיד.
PucksCollisionStrategy
בכדי לממש את ההתנהגות יצרנו מחלקת Puck היורשת ממחלקת Ball.
למחלקה היעודית יש תכונות מוגדרות שונות מBall (גודל קטן יותר, תמונה שונה)
ובנוסף דורסת את שיטת update כך שלא תוריד חיים של השחקן אלא רק תיעלם מהמשחק.

4. על מנת לממש את ההתנהגות הכפולה, השתמשנו בDecorator ה״עוטף״ שתי אסטרטגיות שונות.
בעת התנגשות הDecorator עובר על האסטרטגיות שבשרשותו ומפעיל את פונקציית ההתנגשות שלהן.
שימוש זה ממש את עקרון הOpen/Closed - הקוד הקיים לא השתנה אך כן פתוח להרחבה.
את ההגבלה על מספר האסטרטגיות אותן יכולה להחזיק אסטרטגיה כפולה מימשנו באופן הבא:
כשהמפעל יוצר אסטרטגיה כפולה, הוא מעביר לבנאי שלה ארגומנט בוליאני נוסף
 המציין כי זוהי אסטרטגיה ״מקורית״ ולא מקוננת (Nested).
הבנאי של האסטרטגיה הכפולה עובר בלולאה כמספר האסטרטגיות שהוא אמור להחזיק (2 במקרה שלנו).
בכל פעם הוא בוחן האם הוא מסוגל לקבל שוב אסטרטגיה מיוחדת -
האם מספר האסטרטגיות שהוא מחזיק עד כה (כולל מקוננות)
 ועוד מספר האסטרטגיות שאסטרטגיה כפולה יכול להחזיק לא חורג מהמקסימום.
אם כן - הוא מבקש אסטרטגיה מיוחדת מהמפעל.
 אם לא - הוא מבקש אסטרטגיה ״מיוחדת אך לא כפולה״ (בקוד נקרא ״third״ בארגומנט שהמפעל מקבל)
בחירת עיצוב זה מאפשרת לנו חופש מוחלט לבחור את שני הקבועים
(מספר האסטרטגיות שמחזיקה אסטרטגיה כפולה ומספר האסטרטגיות המקסימלי) בשורות קוד בודדות

5. שינויים בAPI:
Ball:
הוספת שיטת startMove - לצרכי שמירת האחריות של תזוזת הכדור אצל הכדור.
זאת כחלק מהחלטה עיצובית כי יש לשמור על האובייקטים עצמאיים ככל הניתן ואחראים על הפונקציונליות שלהם.
Paddle:
הוספת השיטה isMainPaddle כדי לא לשבור אנקפסולציה (להמנע משימוש בinstanceof ככל הניתן)
CollisionStrategy:
הוספת השיטה getCollisionStrategiesNumber על מנת לספור באופן רקורסיבי את מספר האסטרטגיות שמחזיקה אסטרטגיה כפולה
האסטרגיה הבסיסית שכל האסטרטגיות יורשות ממנה מממשת את השיטה בהחזרת 1
האסטרטגיה הכפולה דורסת את השיטה המקורית וקוראת לשיטה של האסטרטגיות המקוננות
BrickerGameManager:
כהחלטה עיצובית מחלקה זו אחראית על רינדור תמונות, יצירת אובייקטי סאונד וניהול האוביקטים במשחק
מכך נגזרות מספר שיטות פומביות:
readImage - רינדור תמונות
readSound - יצירת קבצי סאונד
getWindowDims - קבלת מימדי חלון המשחק
addObject\removeObject - הוספה ומחיקת אובייקטים
getInputListener - קבלת מצביע לinputListener
getLivesManager - קבלת מצביע למנהל החיים
hasExtraPaddle/setHasExtraPaddle
getBallRadius
